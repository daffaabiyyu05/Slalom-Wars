{
  "Id": 50331774,
  "Comment": "",
  "IsScript": true,
  "RunOnMapInit": false,
  "Script": "\r\n//===========================================================================\r\n//\r\n//  Damage Engine 5.7.1.2 - update requires replacing the JASS script.\r\n//\r\n/*\r\n    Three GUI Damage systems for the community of The Hive,\r\n    Seven vJass Damage systems for the JASS-heads on their pedestals high,\r\n    Nine competing Damage systems, doomed to die,\r\n    One for Bribe on his dark throne\r\n    In the Land of the Hive where the Workshop lies.\r\n    One Damage Engine to rule them all, One Damage Engine to find them,\r\n    One Damage Engine to bring them all and in cross-compatibility unite them.\r\n*/\r\n//! novjass\r\nJASS API (work in progress - I have a lot of documentation to go through):\r\n    struct Damage extends array\r\n        readonly static unit  source        //stores udg_DamageEventSource\r\n        readonly static unit  target        //stores udg_DamageEventTarget\r\n        static real           amount        //stores udg_DamageEventAmount\r\n        readonly unit         sourceUnit    //stores udg_DamageEventSource by index\r\n        readonly unit         targetUnit    //stores udg_DamageEventTarget by index\r\n        real                  damage        //stores udg_DamageEventAmount by index\r\n        readonly real         prevAmt       //stores udg_DamageEventPrevAmt by index\r\n        attacktype            attackType    //stores udg_DamageEventAttackT by index\r\n        damagetype            damageType    //stores udg_DamageEventDamageT by index\r\n        weapontype            weaponType    //stores udg_DamageEventWeaponT by index\r\n        integer               userType      //stores udg_DamageEventType by index\r\n        readonly integer      eFilter       //replaces the previous eventFilter variable\r\n        readonly boolean      isAttack      //stores udg_IsDamageAttack by index\r\n        readonly boolean      isCode        //stores udg_IsDamageCode by index\r\n        readonly boolean      isMelee       //stores udg_IsDamageMelee by index\r\n        readonly boolean      isRanged      //stores udg_IsDamageRanged by index\r\n        readonly boolean      isSpell       //stores udg_IsDamageSpell by index\r\n        real                  armorPierced  //stores udg_DamageEventArmorPierced by index\r\n        integer               armorType     //stores udg_DamageEventArmorT by index\r\n        integer               defenseType   //stores udg_DamageEventDefenseT by index\r\n     \r\n        static boolean operator enabled\r\n        - Set to false to disable the damage event triggers/false to reverse that\r\n     \r\n        static method apply takes unit src, unit tgt, real amt, boolean a, boolean r, attacktype at, damagetype dt, weapontype wt returns Damage\r\n        - Same arguments as \"UnitDamageTarget\" but has the benefit of being performance-friendly during recursive events.\r\n        - Will automatically cause the damage to be registered as Code damage.\r\n     \r\n        static method applySpell takes unit src, unit tgt, real amt, damagetype dt returns Damage\r\n        - A simplified version of the above function that autofills in the booleans, attack type and weapon type.\r\n        static method applyAttack takes unit src, unit tgt, real amt, boolean ranged, attacktype at, weapontype wt returns Damage\r\n        - A different variation of the above which autofills the \"attack\" boolean and sets the damagetype to DAMAGE_TYPE_NORMAL.\r\n    struct DamageTrigger extends array\r\n        method operator filter= takes integer filter returns nothing\r\n        // Apply primary filters such as DamageEngine_FILTER_MELEE/RANGED/SPELL which are based off of limitop handles to enable easier access for GUI folks\r\n        // Full filter list:\r\n        - global integer DamageEngine_FILTER_ATTACK\r\n        - global integer DamageEngine_FILTER_MELEE\r\n        - global integer DamageEngine_FILTER_OTHER\r\n        - global integer DamageEngine_FILTER_RANGED\r\n        - global integer DamageEngine_FILTER_SPELL\r\n        - global integer DamageEngine_FILTER_CODE  \r\n \r\n        boolean configured //set to True after configuring any filters listed below.\r\n \r\n        method configure takes nothing returns nothing\r\n        // Apply custom filters after setting any desired udg_DamageFilter variables (for GUI).\r\n        // Alternatively, vJass users can set these instead. Just be mindful to set the variable\r\n        // \"configured\" to true after settings these.\r\n        unit    source\r\n        unit    target\r\n        integer sourceType\r\n        integer targetType\r\n        integer sourceBuff\r\n        integer targetBuff\r\n        real    damageMin\r\n        integer attackType\r\n        integer damageType\r\n        integer userType\r\n \r\n        //The string in the aruments below requires the following API:\r\n        //  \"\" for standard damage event\r\n        //  \"Modifier(or Mod if you prefer)/After/Lethal/AOE\" for the others\r\n        static method getIndex takes trigger t, string eventName, real value returns integer\r\n        static method registerTrigger takes trigger whichTrig, string var, real weight returns nothing\r\n        static method unregister takes trigger t, string eventName, real value, boolean reset returns boolean\r\n \r\n        static method operator [] takes code c returns trigger\r\n        // Converts a code argument to a trigger, while checking if the same code had already been registered before.\r\n    //The accepted strings here use the same criteria as DamageTrigger.getIndex/registerTrigger/unregister\r\n    function TriggerRegisterDamageEngineEx takes trigger whichTrig, string eventName, real value, integer f returns nothing\r\n    function TriggerRegisterDamageEngine takes trigger whichTrig, string eventName, real value returns nothing\r\n    function RegisterDamageEngineEx takes code c, string eventName, real value, integer f returns nothing\r\n    function RegisterDamageEngine takes code c, string eventName, real value returns nothing\r\n//! endnovjass\r\n//===========================================================================\r\nlibrary DamageEngine\r\nglobals\r\n    private constant boolean USE_GUI        = true      //If you don't use any of the GUI events, set to false to slightly improve performance\r\n                                                       \r\n    private constant boolean USE_SCALING    = USE_GUI   //If you don't need or want to use DamageScalingUser/WC3 then set this to false\r\n    private constant boolean USE_EXTRA      = true      //If you don't use DamageEventLevel or AOEDamageEvent, set this to false\r\n    private constant boolean USE_ARMOR_MOD  = true      //If you do not modify nor detect armor/defense, set this to false\r\n    private constant boolean USE_MELEE_RANGE= true      //If you do not detect melee nor ranged damage, set this to false\r\n    private constant boolean USE_LETHAL     = true      //If you do not use LethalDamageEvent nor negative damage (explosive) types, set this to false\r\n   \r\n    private constant integer LIMBO          = 16        //When manually-enabled recursion is enabled via DamageEngine_recurion, the engine will never go deeper than LIMBO.\r\n   \r\n    public constant integer TYPE_CODE       = 1         //Must be the same as udg_DamageTypeCode, or 0 if you prefer to disable the automatic flag.\r\n    public constant integer TYPE_PURE       = 2         //Must be the same as udg_DamageTypePure\r\n    private constant real   DEATH_VAL       = 0.405     //In case Blizz ever changes this, it'll be a quick fix here.\r\n    private timer           alarm           = CreateTimer()\r\n    private boolean         alarmSet        = false\r\n    //Values to track the original pre-spirit Link/defensive damage values\r\n    private Damage          lastInstance    = 0\r\n    private boolean         canKick         = true\r\n    private boolean         totem           = false\r\n    private boolean array   attacksImmune\r\n    private boolean array   damagesImmune\r\n    //Made global in order to use enable/disable behavior.\r\n    private trigger         t1              = CreateTrigger()\r\n    private trigger         t2              = CreateTrigger()\r\n    private trigger         t3              = CreateTrigger() //Catches, stores recursive events\r\n    //These variables coincide with Blizzard's \"limitop\" type definitions so as to enable users (GUI in particular) with some nice performance perks.\r\n    public constant integer FILTER_ATTACK   = 0     //LESS_THAN\r\n    public constant integer FILTER_MELEE    = 1     //LESS_THAN_OR_EQUAL\r\n    public constant integer FILTER_OTHER    = 2     //EQUAL\r\n    public constant integer FILTER_RANGED   = 3     //GREATER_THAN_OR_EQUAL\r\n    public constant integer FILTER_SPELL    = 4     //GREATER_THAN\r\n    public constant integer FILTER_CODE     = 5     //NOT_EQUAL\r\n    public constant integer FILTER_MAX      = 6\r\n    private integer         eventFilter     = FILTER_OTHER\r\n    public boolean          inception       = false     //When true, it allows your trigger to potentially go recursive up to LIMBO. However it must be set per-trigger throughout the game and not only once per trigger during map initialization.\r\n    private boolean         dreaming        = false\r\n    private integer         sleepLevel      = 0\r\n    private group           proclusGlobal   = CreateGroup() //track sources of recursion\r\n    private group           fischerMorrow   = CreateGroup() //track targets of recursion\r\n    private boolean         kicking         = false\r\n    private boolean         eventsRun       = false\r\n    private keyword         run\r\n    private keyword         trigFrozen\r\n    private keyword         levelsDeep\r\n    private keyword         inceptionTrig\r\n   \r\n    private boolean         hasLethal       = false\r\nendglobals\r\nnative UnitAlive takes unit u returns boolean\r\n//GUI Vars:\r\n/*\r\n    Retained from 3.8 and prior:\r\n    ----------------------------\r\n    unit            udg_DamageEventSource\r\n    unit            udg_DamageEventTarget\r\n    unit            udg_EnhancedDamageTarget\r\n    group           udg_DamageEventAOEGroup\r\n    integer         udg_DamageEventAOE\r\n    integer         udg_DamageEventLevel\r\n    real            udg_DamageModifierEvent\r\n    real            udg_DamageEvent\r\n    real            udg_AfterDamageEvent\r\n    real            udg_DamageEventAmount\r\n    real            udg_DamageEventPrevAmt\r\n    real            udg_AOEDamageEvent\r\n    boolean         udg_DamageEventOverride\r\n    boolean         udg_NextDamageType\r\n    boolean         udg_DamageEventType\r\n    boolean         udg_IsDamageSpell\r\n    //Added in 5.0:\r\n    boolean          udg_IsDamageMelee\r\n    boolean          udg_IsDamageRanged\r\n    unit             udg_AOEDamageSource\r\n    real             udg_LethalDamageEvent\r\n    real             udg_LethalDamageHP\r\n    real             udg_DamageScalingWC3\r\n    integer          udg_DamageEventAttackT\r\n    integer          udg_DamageEventDamageT\r\n    integer          udg_DamageEventWeaponT\r\n    //Added in 5.1:\r\n    boolean          udg_IsDamageCode\r\n    //Added in 5.2:\r\n    integer          udg_DamageEventArmorT\r\n    integer          udg_DamageEventDefenseT\r\n    //Addded in 5.3:\r\n    real             DamageEventArmorPierced\r\n    real             udg_DamageScalingUser\r\n    //Added in 5.4.2 to allow GUI users to re-issue the exact same attack and damage type at the attacker.\r\n    attacktype array udg_CONVERTED_ATTACK_TYPE\r\n    damagetype array udg_CONVERTED_DAMAGE_TYPE\r\n    //Added after Reforged introduced the new native BlzGetDamageIsAttack\r\n    boolean         udg_IsDamageAttack\r\n    //Added in 5.6 to give GUI users control over the \"IsDamageAttack\", \"IsDamageRanged\" and \"DamageEventWeaponT\" field\r\n    boolean         udg_NextDamageIsAttack  //The first boolean value in the UnitDamageTarget native\r\n    boolean         udg_NextDamageIsMelee   //Flag the damage classification as melee\r\n    boolean         udg_NextDamageIsRanged  //The second boolean value in the UnitDamageTarget native\r\n    integer         udg_NextDamageWeaponT   //Allows control over damage sound effect\r\n    //Added in 5.7 to enable efficient, built-in filtering (see the below \"checkConfiguration\" method - I recommend commenting-out anything you don't need in your map)\r\n    integer udg_DamageFilterAttackT\r\n    integer udg_DamageFilterDamageT     //filter for a specific attack/damage type\r\n    unit    udg_DamageFilterSource\r\n    unit    udg_DamageFilterTarget      //filter for a specific source/target\r\n    integer udg_DamageFilterSourceT\r\n    integer udg_DamageFilterTargetT     //unit type of source/target\r\n    integer udg_DamageFilterType        //which DamageEventType was used\r\n    integer udg_DamageFilterSourceB\r\n    integer udg_DamageFilterTargetB     //if source/target has a buff\r\n    real    udg_DamageFilterMinAmount   //only allow a minimum damage threshold\r\n*/\r\nstruct DamageTrigger extends array\r\n   \r\n    //Map-makers should comment-out any booleans they will never need to check for.\r\n    method checkConfiguration takes nothing returns boolean\r\n        if this.userType != 0 and udg_DamageEventType != this.userType then\r\n        elseif this.source != null and this.source != udg_DamageEventSource then\r\n        elseif this.target != null and this.target != udg_DamageEventTarget then\r\n        elseif this.attackType >= 0 and this.attackType != udg_DamageEventAttackT then\r\n        elseif this.damageType >= 0 and this.damageType != udg_DamageEventDamageT then\r\n        elseif this.sourceType != 0 and GetUnitTypeId(udg_DamageEventSource) != this.sourceType then\r\n        elseif this.targetType != 0 and GetUnitTypeId(udg_DamageEventTarget) != this.targetType then\r\n        elseif this.sourceBuff != 0 and GetUnitAbilityLevel(udg_DamageEventSource, this.sourceBuff) == 0 then\r\n        elseif this.targetBuff != 0 and GetUnitAbilityLevel(udg_DamageEventTarget, this.targetBuff) == 0 then\r\n        elseif udg_DamageEventAmount > this.damageMin then\r\n            return true\r\n        endif\r\n        return false\r\n    endmethod\r\n   \r\n    //The below variables are constant\r\n    readonly static thistype        MOD             = 1\r\n    readonly static thistype        SHIELD          = 4\r\n    readonly static thistype        DAMAGE          = 5\r\n    readonly static thistype        ZERO            = 6\r\n    readonly static thistype        AFTER           = 7\r\n    readonly static thistype        LETHAL          = 8\r\n    readonly static thistype        AOE             = 9\r\n    private static integer          count           = 9\r\n    static thistype                 lastRegistered  = 0\r\n    private static thistype array   trigIndexStack\r\n    static thistype                 eventIndex = 0\r\n    static boolean array            filters\r\n    readonly string                 eventStr\r\n    readonly real                   weight\r\n    boolean                         configured\r\n    boolean                         usingGUI\r\n    //The below variables are private\r\n    private thistype                next\r\n    private trigger                 rootTrig\r\n    boolean                         trigFrozen      //Whether the trigger is currently disabled due to recursion\r\n    integer                         levelsDeep      //How deep the user recursion currently is.\r\n    boolean                         inceptionTrig   //Added in 5.4.2 to simplify the inception variable for very complex DamageEvent trigger.\r\n    unit    source\r\n    unit    target\r\n    integer sourceType\r\n    integer targetType\r\n    integer sourceBuff\r\n    integer targetBuff\r\n    real    damageMin\r\n    integer attackType\r\n    integer damageType\r\n    integer userType\r\n    method configure takes nothing returns nothing\r\n        set this.attackType         = udg_DamageFilterAttackT\r\n        set this.damageType         = udg_DamageFilterDamageT\r\n        set this.source             = udg_DamageFilterSource\r\n        set this.target             = udg_DamageFilterTarget\r\n        set this.sourceType         = udg_DamageFilterSourceT\r\n        set this.targetType         = udg_DamageFilterTargetT\r\n        set this.sourceBuff         = udg_DamageFilterSourceB\r\n        set this.targetBuff         = udg_DamageFilterTargetB\r\n        set this.userType           = udg_DamageFilterType\r\n        set this.damageMin          = udg_DamageFilterMinAmount\r\n \r\n        set udg_DamageFilterAttackT =-1\r\n        set udg_DamageFilterDamageT =-1\r\n        set udg_DamageFilterSource  = null\r\n        set udg_DamageFilterTarget  = null\r\n        set udg_DamageFilterSourceT = 0\r\n        set udg_DamageFilterTargetT = 0\r\n        set udg_DamageFilterType    = 0\r\n        set udg_DamageFilterSourceB = 0\r\n        set udg_DamageFilterTargetB = 0\r\n        set udg_DamageFilterMinAmount=0.00\r\n \r\n        set this.configured         = true\r\n    endmethod\r\n    static method setGUIFromStruct takes boolean full returns nothing\r\n        set udg_DamageEventAmount       = Damage.index.damage\r\n        set udg_DamageEventAttackT      = GetHandleId(Damage.index.attackType)\r\n        set udg_DamageEventDamageT      = GetHandleId(Damage.index.damageType)\r\n        set udg_DamageEventWeaponT      = GetHandleId(Damage.index.weaponType)\r\n        set udg_DamageEventType         = Damage.index.userType\r\nstatic if USE_ARMOR_MOD then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        set udg_DamageEventArmorPierced = Damage.index.armorPierced\r\n        set udg_DamageEventArmorT       = Damage.index.armorType\r\n        set udg_DamageEventDefenseT     = Damage.index.defenseType\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        if full then\r\n            set udg_DamageEventSource   = Damage.index.sourceUnit\r\n            set udg_DamageEventTarget   = Damage.index.targetUnit\r\n            set udg_DamageEventPrevAmt  = Damage.index.prevAmt\r\n            set udg_IsDamageAttack      = Damage.index.isAttack\r\n            set udg_IsDamageCode        = Damage.index.isCode\r\n            set udg_IsDamageSpell       = Damage.index.isSpell\r\nstatic if USE_MELEE_RANGE then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            set udg_IsDamageMelee       = Damage.index.isMelee\r\n            set udg_IsDamageRanged      = Damage.index.isRanged\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        endif\r\n    endmethod\r\n    static method setStructFromGUI takes nothing returns nothing\r\n        set Damage.index.damage        = udg_DamageEventAmount\r\n        set Damage.index.attackType    = ConvertAttackType(udg_DamageEventAttackT)\r\n        set Damage.index.damageType    = ConvertDamageType(udg_DamageEventDamageT)\r\n        set Damage.index.weaponType    = ConvertWeaponType(udg_DamageEventWeaponT)\r\n        set Damage.index.userType      = udg_DamageEventType\r\nstatic if USE_ARMOR_MOD then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        set Damage.index.armorPierced  = udg_DamageEventArmorPierced\r\n        set Damage.index.armorType     = udg_DamageEventArmorT\r\n        set Damage.index.defenseType   = udg_DamageEventDefenseT\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n    endmethod\r\n    static method getVerboseStr takes string eventName returns string\r\n        if eventName == \"Modifier\" or eventName == \"Mod\" then\r\n            return \"udg_DamageModifierEvent\"\r\n        endif\r\n        return \"udg_\" + eventName + \"DamageEvent\"\r\n    endmethod\r\n    private static method getStrIndex takes string var, real lbs returns thistype\r\n        local integer root = R2I(lbs)\r\n        if var == \"udg_DamageModifierEvent\" then\r\n            if root >= 4 then\r\n                set root= SHIELD //4.00 or higher\r\n            else  \r\n                set root= MOD    //Less than 4.00\r\n            endif\r\n        elseif var == \"udg_DamageEvent\" then\r\n            if root == 2 or root == 0 then\r\n                set root= ZERO\r\n            else\r\n                set root= DAMAGE //Above 0.00 but less than 2.00, generally would just be 1.00\r\n            endif\r\n        elseif var == \"udg_AfterDamageEvent\" then\r\n            set root    = AFTER\r\n        elseif var == \"udg_LethalDamageEvent\" then\r\n            set root    = LETHAL\r\n        elseif var == \"udg_AOEDamageEvent\" then\r\n            set root    = AOE\r\n        else\r\n            set root    = 0\r\n            //! runtextmacro optional DAMAGE_EVENT_REG_PLUGIN_GDD()\r\n            //! runtextmacro optional DAMAGE_EVENT_REG_PLUGIN_PDD()\r\n            //! runtextmacro optional DAMAGE_EVENT_REG_PLUGIN_01()\r\n            //! runtextmacro optional DAMAGE_EVENT_REG_PLUGIN_02()\r\n            //! runtextmacro optional DAMAGE_EVENT_REG_PLUGIN_03()\r\n            //! runtextmacro optional DAMAGE_EVENT_REG_PLUGIN_04()\r\n            //! runtextmacro optional DAMAGE_EVENT_REG_PLUGIN_05()\r\n        endif\r\n        return root\r\n    endmethod\r\n    private method toggleAllFilters takes boolean flag returns nothing\r\n        set filters[this + FILTER_ATTACK]   = flag\r\n        set filters[this + FILTER_MELEE]    = flag\r\n        set filters[this + FILTER_OTHER]    = flag\r\n        set filters[this + FILTER_RANGED]   = flag\r\n        set filters[this + FILTER_SPELL]    = flag\r\n        set filters[this + FILTER_CODE]     = flag\r\n    endmethod\r\n    method operator filter= takes integer f returns nothing\r\n        set this = this*FILTER_MAX\r\n        if f == FILTER_OTHER then\r\n            call this.toggleAllFilters(true)\r\n        else\r\n            if f == FILTER_ATTACK then\r\n                set filters[this + FILTER_ATTACK]   = true\r\n                set filters[this + FILTER_MELEE]    = true\r\n                set filters[this + FILTER_RANGED]   = true\r\n            else\r\n                set filters[this + f] = true\r\n            endif\r\n        endif\r\n    endmethod\r\n    static method registerVerbose takes trigger whichTrig, string var, real lbs, boolean GUI, integer filt returns thistype\r\n        local thistype index= getStrIndex(var, lbs)\r\n        local thistype i    = 0\r\n        local thistype id   = 0\r\n \r\n        if index == 0 then\r\n            return 0\r\n        elseif lastRegistered.rootTrig == whichTrig and lastRegistered.usingGUI then\r\n            set filters[lastRegistered*FILTER_MAX + filt] = true //allows GUI to register multiple different types of Damage filters to the same trigger\r\n            return 0\r\n        endif\r\n \r\n        if not hasLethal and index == LETHAL then\r\n            set hasLethal = true\r\n        endif\r\n        if trigIndexStack[0] == 0 then\r\n            set count              = count + 1   //List runs from index 10 and up\r\n            set id                 = count\r\n        else\r\n            set id                 = trigIndexStack[0]\r\n            set trigIndexStack[0]  = trigIndexStack[id]\r\n        endif\r\n        set lastRegistered         = id\r\n        set id.filter              = filt\r\n        set id.rootTrig            = whichTrig\r\n        set id.usingGUI            = GUI\r\n        set id.weight              = lbs\r\n        set id.eventStr            = var\r\n       \r\n        //Next 2 lines added to fix a bug when using manual vJass configuration,\r\n        //discovered and solved by lolreported\r\n        set id.attackType          = -1\r\n        set id.damageType          = -1\r\n \r\n        loop\r\n            set i = index.next\r\n            exitwhen i == 0 or lbs < i.weight\r\n            set index = i\r\n        endloop      \r\n        set index.next = id\r\n        set id.next    = i\r\n \r\n        //call BJDebugMsg(\"Registered \" + I2S(id) + \" to \" + I2S(index) + \" and before \" + I2S(i))\r\n        return lastRegistered\r\n    endmethod\r\n    static method registerTrigger takes trigger t, string var, real lbs returns thistype\r\n        return registerVerbose(t, DamageTrigger.getVerboseStr(var), lbs, false, FILTER_OTHER)\r\n    endmethod\r\n    private static thistype prev = 0\r\n    static method getIndex takes trigger t, string eventName, real lbs returns thistype\r\n        local thistype index = getStrIndex(getVerboseStr(eventName), lbs)\r\n        loop\r\n            set prev = index\r\n            set index = index.next\r\n            exitwhen index == 0 or index.rootTrig == t\r\n        endloop\r\n        return index\r\n    endmethod\r\n    static method unregister takes trigger t, string eventName, real lbs, boolean reset returns boolean\r\n        local thistype index        = getIndex(t, eventName, lbs)\r\n        if index == 0 then\r\n            return false\r\n        endif\r\n        set prev.next               = index.next\r\n     \r\n        set trigIndexStack[index]   = trigIndexStack[0]\r\n        set trigIndexStack[0]       = index\r\n \r\n        if reset then\r\n            call index.configure()\r\n            set index.configured    = false\r\n            set index               = index*FILTER_MAX\r\n            call index.toggleAllFilters(false)\r\n        endif\r\n        return true\r\n    endmethod\r\n    method run takes nothing returns nothing\r\n        local integer cat = this\r\n        local Damage d = Damage.index\r\nstatic if USE_GUI then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        local boolean structUnset = false\r\n        local boolean guiUnset = false\r\n        local boolean mod = cat <= DAMAGE\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        if dreaming then\r\n            return    \r\n        endif          \r\n        set dreaming = true\r\n        call DisableTrigger(t1)\r\n        call DisableTrigger(t2)\r\n        call EnableTrigger(t3)\r\n        //call BJDebugMsg(\"Start of event running\")\r\n        loop                                  \r\n            set this = this.next\r\n            exitwhen this == 0\r\n            exitwhen cat == MOD and (udg_DamageEventOverride or udg_DamageEventType == TYPE_PURE)\r\n            exitwhen cat == SHIELD and udg_DamageEventAmount <= 0.00\r\nstatic if USE_LETHAL then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            exitwhen cat == LETHAL and udg_LethalDamageHP > DEATH_VAL\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n         \r\n            set eventIndex = this\r\n            if not this.trigFrozen and filters[this*FILTER_MAX + d.eFilter] and IsTriggerEnabled(this.rootTrig) and (not this.configured or this.checkConfiguration()) then\r\nstatic if USE_GUI then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n                if mod then\r\n                    if this.usingGUI then\r\n                        if guiUnset then\r\n                            set guiUnset = false\r\n                            call setGUIFromStruct(false)\r\n                        endif\r\n                        //! runtextmacro optional DAMAGE_EVENT_FILTER_PLUGIN_PDD()\r\n                    elseif structUnset then\r\n                        set structUnset = false\r\n                        call setStructFromGUI()\r\n                    endif\r\n                endif\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n                //! runtextmacro optional DAMAGE_EVENT_FILTER_PLUGIN_01()\r\n                //! runtextmacro optional DAMAGE_EVENT_FILTER_PLUGIN_02()\r\n                //! runtextmacro optional DAMAGE_EVENT_FILTER_PLUGIN_03()\r\n                //! runtextmacro optional DAMAGE_EVENT_FILTER_PLUGIN_04()\r\n                //! runtextmacro optional DAMAGE_EVENT_FILTER_PLUGIN_05()\r\n               \r\n                //JASS users who do not use actions can modify the below block to just evaluate.\r\n                //It should not make any perceptable difference in terms of performance.\r\n                if TriggerEvaluate(this.rootTrig) then\r\n                    call TriggerExecute(this.rootTrig)\r\n                endif\r\n                //! runtextmacro optional DAMAGE_EVENT_MOD_PLUGIN_01()\r\n                //! runtextmacro optional DAMAGE_EVENT_MOD_PLUGIN_02()\r\n                //! runtextmacro optional DAMAGE_EVENT_MOD_PLUGIN_03()\r\n                //! runtextmacro optional DAMAGE_EVENT_MOD_PLUGIN_04()\r\n                //! runtextmacro optional DAMAGE_EVENT_MOD_PLUGIN_05()\r\nstatic if USE_GUI then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n                if mod then\r\n                    if this.usingGUI then\r\n                        //! runtextmacro optional DAMAGE_EVENT_MOD_PLUGIN_PDD()\r\n                        if cat != MOD then\r\n                            set d.damage        = udg_DamageEventAmount\r\n                        else\r\n                            set structUnset = true\r\n                        endif\r\n                    elseif cat != MOD then\r\n                        set udg_DamageEventAmount = d.damage\r\n                    else\r\n                        set guiUnset = true\r\n                    endif\r\n                endif\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            endif\r\n        endloop\r\nstatic if USE_GUI then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        if structUnset then\r\n            call setStructFromGUI()\r\n        endif\r\n        if guiUnset then\r\n            call setGUIFromStruct(false)\r\n        endif\r\nelse// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        call setGUIFromStruct(false)\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        //call BJDebugMsg(\"End of event running\")\r\n        call DisableTrigger(t3)\r\n        call EnableTrigger(t1)\r\n        call EnableTrigger(t2)\r\n        set dreaming                                = false\r\n    endmethod\r\n    static trigger array    autoTriggers\r\n    static boolexpr array   autoFuncs\r\n    static integer          autoN = 0\r\n    static method operator [] takes code c returns trigger\r\n        local integer i             = 0\r\n        local boolexpr b            = Filter(c)\r\n        loop\r\n            if i == autoN then\r\n                set autoTriggers[i] = CreateTrigger()\r\n                set autoFuncs[i]    = b\r\n                call TriggerAddCondition(autoTriggers[i], b)\r\n                exitwhen true\r\n            endif\r\n            set i = i + 1\r\n            exitwhen b == autoFuncs[i]\r\n        endloop\r\n        return autoTriggers[i]\r\n    endmethod\r\nendstruct\r\n//! runtextmacro optional DAMAGE_EVENT_USER_STRUCT_PLUGIN_01()\r\n//! runtextmacro optional DAMAGE_EVENT_USER_STRUCT_PLUGIN_02()\r\n//! runtextmacro optional DAMAGE_EVENT_USER_STRUCT_PLUGIN_03()\r\n//! runtextmacro optional DAMAGE_EVENT_USER_STRUCT_PLUGIN_04()\r\n//! runtextmacro optional DAMAGE_EVENT_USER_STRUCT_PLUGIN_05()\r\nstruct Damage extends array\r\n    readonly unit           sourceUnit    //stores udg_DamageEventSource\r\n    readonly unit           targetUnit    //stores udg_DamageEventTarget\r\n    real                    damage        //stores udg_DamageEventAmount\r\n    readonly real           prevAmt       //stores udg_DamageEventPrevAmt\r\n    attacktype              attackType    //stores udg_DamageEventAttackT\r\n    damagetype              damageType    //stores udg_DamageEventDamageT\r\n    weapontype              weaponType    //stores udg_DamageEventWeaponT\r\n    integer                 userType      //stores udg_DamageEventType\r\n    readonly boolean        isAttack      //stores udg_IsDamageAttack\r\n    readonly boolean        isCode        //stores udg_IsDamageCode\r\n    readonly boolean        isSpell       //stores udg_IsDamageSpell\r\nstatic if USE_MELEE_RANGE then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n    readonly boolean        isMelee       //stores udg_IsDamageMelee\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n    readonly boolean        isRanged      //stores udg_IsDamageRanged\r\n    readonly integer        eFilter       //stores the previous eventFilter variable\r\n   \r\nstatic if USE_ARMOR_MOD then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n    real                    armorPierced  //stores udg_DamageEventArmorPierced\r\n    integer                 armorType     //stores udg_DamageEventArmorT\r\n    integer                 defenseType   //stores udg_DamageEventDefenseT\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n    readonly static Damage  index       = 0\r\n    private static Damage   damageStack = 0\r\n    private static Damage   prepped     = 0\r\n    private static integer  count = 0 //The number of currently-running queued or sequential damage instances\r\n    private Damage          stackRef\r\n    private DamageTrigger   recursiveTrig\r\n    private integer         prevArmorT\r\n    private integer         prevDefenseT\r\n    static method operator source takes nothing returns unit\r\n        return udg_DamageEventSource\r\n    endmethod\r\n    static method operator target takes nothing returns unit\r\n        return udg_DamageEventTarget\r\n    endmethod\r\n    static method operator amount takes nothing returns real\r\n        return Damage.index.damage\r\n    endmethod\r\n    static method operator amount= takes real r returns nothing\r\n        set Damage.index.damage = r\r\n    endmethod\r\n   \r\nstatic if USE_ARMOR_MOD then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n    private method setArmor takes boolean reset returns nothing\r\n        local real pierce\r\n        local integer at\r\n        local integer dt\r\n        if reset then\r\n            set pierce =  udg_DamageEventArmorPierced\r\n            set at     =  Damage.index.prevArmorT\r\n            set dt     =  Damage.index.prevDefenseT\r\n            set udg_DamageEventArmorPierced = 0.00\r\n            set this.armorPierced           = 0.00\r\n        else\r\n            set pierce = -udg_DamageEventArmorPierced\r\n            set at     =  udg_DamageEventArmorT\r\n            set dt     =  udg_DamageEventDefenseT\r\n        endif\r\n        if pierce != 0.00 then\r\n            call BlzSetUnitArmor(udg_DamageEventTarget, BlzGetUnitArmor(udg_DamageEventTarget) + pierce)\r\n        endif\r\n        if Damage.index.prevArmorT != udg_DamageEventArmorT then\r\n            call BlzSetUnitIntegerField(udg_DamageEventTarget, UNIT_IF_ARMOR_TYPE, at)\r\n        endif\r\n        if Damage.index.prevDefenseT != udg_DamageEventDefenseT then\r\n            call BlzSetUnitIntegerField(udg_DamageEventTarget, UNIT_IF_DEFENSE_TYPE, dt)\r\n        endif\r\n    endmethod\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\nstatic if USE_EXTRA then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n    private static method onAOEEnd takes nothing returns nothing\r\n        if udg_DamageEventAOE > 1 then\r\n            call DamageTrigger.AOE.run()\r\n        endif\r\n        set udg_DamageEventAOE          = 0\r\n        set udg_DamageEventLevel        = 0\r\n        set udg_EnhancedDamageTarget    = null\r\n        set udg_AOEDamageSource         = null\r\n        call GroupClear(udg_DamageEventAOEGroup)\r\n    endmethod\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n   \r\n    private static method afterDamage takes nothing returns nothing\r\n        if udg_DamageEventPrevAmt != 0.00 and udg_DamageEventDamageT != 0 then\r\n            call DamageTrigger.AFTER.run()\r\n            set udg_DamageEventDamageT  = 0\r\n            set udg_DamageEventPrevAmt  = 0.00\r\n        endif\r\n    endmethod\r\n    private method doPreEvents takes boolean natural returns boolean\r\nstatic if USE_ARMOR_MOD then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        set this.armorType      = BlzGetUnitIntegerField(this.targetUnit, UNIT_IF_ARMOR_TYPE)\r\n        set this.defenseType    = BlzGetUnitIntegerField(this.targetUnit, UNIT_IF_DEFENSE_TYPE)\r\n        set this.prevArmorT     = this.armorType\r\n        set this.prevDefenseT   = this.defenseType\r\n        set this.armorPierced   = 0.00\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        set Damage.index        = this\r\n        call DamageTrigger.setGUIFromStruct(true)\r\n       \r\n        call GroupAddUnit(proclusGlobal, udg_DamageEventSource)\r\n        call GroupAddUnit(fischerMorrow, udg_DamageEventTarget)\r\n        //! runtextmacro optional DAMAGE_EVENT_PRE_VARS_PLUGIN_01()\r\n        //! runtextmacro optional DAMAGE_EVENT_PRE_VARS_PLUGIN_02()\r\n        //! runtextmacro optional DAMAGE_EVENT_PRE_VARS_PLUGIN_03()\r\n        //! runtextmacro optional DAMAGE_EVENT_PRE_VARS_PLUGIN_04()\r\n        //! runtextmacro optional DAMAGE_EVENT_PRE_VARS_PLUGIN_05()\r\n        if udg_DamageEventAmount != 0.00 then\r\n            set udg_DamageEventOverride = udg_DamageEventDamageT == 0\r\n            call DamageTrigger.MOD.run()\r\nstatic if not USE_GUI then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            call DamageTrigger.setGUIFromStruct(false)\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            if natural then\r\n                call BlzSetEventAttackType(this.attackType)\r\n                call BlzSetEventDamageType(this.damageType)\r\n                call BlzSetEventWeaponType(this.weaponType)\r\n                call BlzSetEventDamage(udg_DamageEventAmount)\r\n            endif\r\nstatic if USE_ARMOR_MOD then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            call this.setArmor(false)\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            return false\r\n        endif\r\n        return true\r\n    endmethod\r\n    private static method unfreeze takes nothing returns nothing\r\n        local Damage i = damageStack\r\n        loop\r\n            exitwhen i == 0\r\n            set i                                    = i - 1\r\n            set i.stackRef.recursiveTrig.trigFrozen  = false\r\n            set i.stackRef.recursiveTrig.levelsDeep  = 0\r\n        endloop                          \r\n        call EnableTrigger(t1)\r\n        call EnableTrigger(t2)\r\n        set kicking                                 = false\r\n        set damageStack                             = 0\r\n        set prepped                                 = 0\r\n        set dreaming                                = false\r\n        set sleepLevel                              = 0\r\n        call GroupClear(proclusGlobal)\r\n        call GroupClear(fischerMorrow)\r\n        //call BJDebugMsg(\"Cleared up the groups\")\r\n    endmethod\r\n    static method finish takes nothing returns nothing\r\n        local Damage i                                  = 0\r\n        local integer exit                        \r\n        if eventsRun then                        \r\n            set eventsRun                               = false\r\n            call afterDamage()\r\n        endif\r\n        if canKick and not kicking then\r\n            if damageStack != 0 then\r\n                set kicking                             = true\r\n                loop\r\n                    set sleepLevel                      = sleepLevel + 1\r\n                    set exit                            = damageStack\r\n                    loop\r\n                        set prepped                     = i.stackRef\r\n                        if UnitAlive(prepped.targetUnit) then //Added just in case dead units had issues.\r\n                            call prepped.doPreEvents(false) //don't evaluate the pre-event\r\n                            if prepped.damage > 0.00 then\r\n                                call DisableTrigger(t1) //Force only the after armor event to run.\r\n                                call EnableTrigger(t2)  //in case the user forgot to re-enable this\r\n                                set totem               = true\r\n                                call UnitDamageTarget(prepped.sourceUnit, prepped.targetUnit, prepped.damage, prepped.isAttack, prepped.isRanged, prepped.attackType, prepped.damageType, prepped.weaponType)\r\n                            else\r\n                                //No new events run at all in this case\r\n                                if udg_DamageEventDamageT != 0 then\r\n                                    call DamageTrigger.DAMAGE.run()\r\n                                endif\r\n                                if prepped.damage < 0.00 then\r\n                                    //No need for BlzSetEventDamage here\r\n                                    call SetWidgetLife(prepped.targetUnit, GetWidgetLife(prepped.targetUnit) - prepped.damage)\r\n                                endif\r\nstatic if USE_ARMOR_MOD then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n                                call prepped.setArmor(true)\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n                            endif\r\n                            call afterDamage()\r\n                        endif\r\n                        set i = i + 1\r\n                        exitwhen i == exit\r\n                    endloop\r\n                    exitwhen i == damageStack\r\n                endloop\r\n            endif\r\n            call unfreeze()\r\n        endif\r\n    endmethod\r\n    private static method failsafeClear takes nothing returns nothing\r\nstatic if USE_ARMOR_MOD then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        call Damage.index.setArmor(true)\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        set canKick         = true\r\n        set kicking         = false\r\n        set totem           = false\r\n        if udg_DamageEventDamageT != 0 then\r\n            call DamageTrigger.DAMAGE.run()\r\n            set eventsRun   = true\r\n        endif\r\n        call finish()\r\n    endmethod\r\n    static method operator enabled= takes boolean b returns nothing\r\n        if b then\r\n            if dreaming then\r\n                call EnableTrigger(t3)\r\n            else\r\n                call EnableTrigger(t1)\r\n                call EnableTrigger(t2)\r\n            endif\r\n        else\r\n            if dreaming then\r\n                call DisableTrigger(t3)\r\n            else\r\n                call DisableTrigger(t1)\r\n                call DisableTrigger(t2)\r\n            endif\r\n        endif\r\n    endmethod\r\n    static method operator enabled takes nothing returns boolean\r\n        return IsTriggerEnabled(t1)\r\n    endmethod\r\n   \r\n    private static boolean arisen = false\r\n   \r\n    private static method getOutOfBed takes nothing returns nothing\r\n        if totem then\r\n            call failsafeClear() //WarCraft 3 didn't run the DAMAGED event despite running the DAMAGING event.\r\n        else\r\n            set canKick     = true\r\n            set kicking     = false\r\n            call finish()\r\n        endif\r\nstatic if USE_EXTRA then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        call onAOEEnd()\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        set arisen = true\r\n    endmethod\r\n   \r\n    private static method wakeUp takes nothing returns nothing\r\n        set dreaming = false\r\n        set Damage.enabled = true\r\n        call ForForce(bj_FORCE_PLAYER[0], function thistype.getOutOfBed) //Moved to a new thread in case of a thread crash\r\n        if not arisen then\r\n            //call BJDebugMsg(\"DamageEngine issue: thread crashed!\")\r\n            call unfreeze()\r\n        else\r\n            set arisen = false\r\n        endif\r\n        set Damage.count    = 0\r\n        set Damage.index    = 0\r\n        set alarmSet        = false\r\n        //call BJDebugMsg(\"Timer wrapped up\")\r\n    endmethod\r\n    private method addRecursive takes nothing returns nothing\r\n        if this.damage != 0.00 then\r\n            set this.recursiveTrig = DamageTrigger.eventIndex\r\n            if not this.isCode then\r\n                set this.isCode = true\r\n                set this.userType = TYPE_CODE\r\n            endif\r\n            set inception = inception or DamageTrigger.eventIndex.inceptionTrig\r\n            if kicking and IsUnitInGroup(this.sourceUnit, proclusGlobal) and IsUnitInGroup(this.targetUnit, fischerMorrow) then\r\n                if not inception then\r\n                    set DamageTrigger.eventIndex.trigFrozen = true\r\n                elseif not DamageTrigger.eventIndex.trigFrozen then\r\n                    set DamageTrigger.eventIndex.inceptionTrig = true\r\n                    if DamageTrigger.eventIndex.levelsDeep < sleepLevel then\r\n                        set DamageTrigger.eventIndex.levelsDeep = DamageTrigger.eventIndex.levelsDeep + 1\r\n                        if DamageTrigger.eventIndex.levelsDeep >= LIMBO then\r\n                            set DamageTrigger.eventIndex.trigFrozen = true\r\n                        endif\r\n                    endif\r\n                endif\r\n            endif\r\n            set damageStack.stackRef = this\r\n            set damageStack = damageStack + 1\r\n            //call BJDebugMsg(\"damageStack: \" + I2S(damageStack) + \" levelsDeep: \" + I2S(DamageTrigger.eventIndex.levelsDeep) + \" sleepLevel: \" + I2S(sleepLevel))\r\n        endif\r\n        set inception = false\r\n    endmethod\r\n    private static method clearNexts takes nothing returns nothing\r\n        set udg_NextDamageIsAttack      = false\r\n        set udg_NextDamageType          = 0\r\n        set udg_NextDamageWeaponT       = 0\r\nstatic if USE_MELEE_RANGE then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        set udg_NextDamageIsMelee       = false\r\n        set udg_NextDamageIsRanged      = false\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n    endmethod\r\n    static method create takes unit src, unit tgt, real amt, boolean a, attacktype at, damagetype dt, weapontype wt returns Damage\r\n        local Damage d      = Damage.count + 1\r\n        set Damage.count    = d\r\n        set d.sourceUnit    = src\r\n        set d.targetUnit    = tgt\r\n        set d.damage        = amt\r\n        set d.prevAmt       = amt\r\n                     \r\n        set d.attackType    = at\r\n        set d.damageType    = dt\r\n        set d.weaponType    = wt\r\n                     \r\n        set d.isAttack      = udg_NextDamageIsAttack or a\r\n        set d.isSpell       = d.attackType == null and not d.isAttack\r\n        return d\r\n    endmethod\r\n    private static method createFromEvent takes nothing returns Damage\r\n        local Damage d                  = create(GetEventDamageSource(), GetTriggerUnit(), GetEventDamage(), BlzGetEventIsAttack(), BlzGetEventAttackType(), BlzGetEventDamageType(), BlzGetEventWeaponType())\r\n        set d.isCode                    = udg_NextDamageType != 0 or udg_NextDamageIsAttack or udg_NextDamageIsRanged or udg_NextDamageIsMelee or d.damageType == DAMAGE_TYPE_MIND or udg_NextDamageWeaponT != 0 or (d.damage != 0.00 and d.damageType == DAMAGE_TYPE_UNKNOWN)\r\n \r\n        if d.isCode then\r\n            if udg_NextDamageType != 0 then\r\n                set d.userType          = udg_NextDamageType\r\n            else\r\n                set d.userType          = TYPE_CODE\r\n            endif\r\nstatic if USE_MELEE_RANGE then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            set d.isMelee               = udg_NextDamageIsMelee\r\n            set d.isRanged              = udg_NextDamageIsRanged\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            set d.eFilter               = FILTER_CODE\r\n            if udg_NextDamageWeaponT != 0 then\r\n                set d.weaponType        = ConvertWeaponType(udg_NextDamageWeaponT)\r\n                set udg_NextDamageWeaponT = 0\r\n            endif\r\n        else\r\n            set d.userType              = 0\r\n            if d.damageType == DAMAGE_TYPE_NORMAL and d.isAttack then\r\nstatic if USE_MELEE_RANGE then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n                set d.isMelee           = IsUnitType(d.sourceUnit, UNIT_TYPE_MELEE_ATTACKER)\r\n                set d.isRanged          = IsUnitType(d.sourceUnit, UNIT_TYPE_RANGED_ATTACKER)\r\n                if d.isMelee and d.isRanged then\r\n                    set d.isMelee       = d.weaponType != null  // Melee units play a sound when damaging\r\n                    set d.isRanged      = not d.isMelee         // In the case where a unit is both ranged and melee, the ranged attack plays no sound.\r\n                endif\r\n                if d.isMelee then\r\n                    set d.eFilter       = FILTER_MELEE\r\n                elseif d.isRanged then\r\n                    set d.eFilter       = FILTER_RANGED\r\n                else\r\n                    set d.eFilter       = FILTER_ATTACK\r\n                endif\r\nelse\r\n                set d.eFilter           = FILTER_ATTACK\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            else\r\n                if d.isSpell then\r\n                    set d.eFilter       = FILTER_SPELL\r\n                else\r\n                    set d.eFilter       = FILTER_OTHER\r\n                endif\r\nstatic if USE_MELEE_RANGE then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n                set d.isMelee           = false\r\n                set d.isRanged          = false\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            endif\r\n        endif\r\n        call clearNexts()\r\n        return d\r\n    endmethod\r\n    private static method onRecursion takes nothing returns boolean //New in 5.7\r\n        local Damage d  = Damage.createFromEvent()\r\n        call d.addRecursive()\r\n        call BlzSetEventDamage(0.00)\r\n        return false\r\n    endmethod\r\n    private static method onDamaging takes nothing returns boolean\r\n        local Damage d              = Damage.createFromEvent()\r\n        //call BJDebugMsg(\"Pre-damage event running for \" + GetUnitName(GetTriggerUnit()))\r\n        if alarmSet then\r\n            if totem then //WarCraft 3 didn't run the DAMAGED event despite running the DAMAGING event.\r\n                if d.damageType == DAMAGE_TYPE_SPIRIT_LINK or d.damageType == DAMAGE_TYPE_DEFENSIVE or d.damageType == DAMAGE_TYPE_PLANT then\r\n                    set totem       = false\r\n                    set lastInstance= Damage.index\r\n                    set canKick     = false\r\n                else\r\n                    call failsafeClear() //Not an overlapping event - just wrap it up\r\n                endif\r\n            else\r\n                call finish() //wrap up any previous damage index\r\n            endif\r\n           \r\nstatic if USE_EXTRA then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            if d.sourceUnit != udg_AOEDamageSource then\r\n                call onAOEEnd()\r\n                set udg_AOEDamageSource = d.sourceUnit\r\n            elseif d.targetUnit == udg_EnhancedDamageTarget then\r\n                set udg_DamageEventLevel= udg_DamageEventLevel + 1\r\n            elseif not IsUnitInGroup(d.targetUnit, udg_DamageEventAOEGroup) then\r\n                set udg_DamageEventAOE  = udg_DamageEventAOE + 1\r\n            endif\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        else\r\n            call TimerStart(alarm, 0.00, false, function Damage.wakeUp)\r\n            set alarmSet                = true\r\nstatic if USE_EXTRA then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            set udg_AOEDamageSource     = d.sourceUnit\r\n            set udg_EnhancedDamageTarget= d.targetUnit\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        endif\r\nstatic if USE_EXTRA then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        call GroupAddUnit(udg_DamageEventAOEGroup, d.targetUnit)\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        if d.doPreEvents(true) then\r\n            call DamageTrigger.ZERO.run()\r\n            set canKick                 = true\r\n            call finish()\r\n        endif\r\n        set totem                       = lastInstance == 0 or attacksImmune[udg_DamageEventAttackT] or damagesImmune[udg_DamageEventDamageT] or not IsUnitType(udg_DamageEventTarget, UNIT_TYPE_MAGIC_IMMUNE)\r\n        return false\r\n    endmethod\r\n    private static method onDamaged takes nothing returns boolean\r\n        local real r                    = GetEventDamage()\r\n        local Damage d                  = Damage.index\r\n        //call BJDebugMsg(\"Second damage event running for \" + GetUnitName(GetTriggerUnit()))\r\n        if prepped > 0 then\r\n            set prepped                 = 0\r\n        elseif dreaming or d.prevAmt == 0.00 then\r\n            return false\r\n        elseif totem then\r\n            set totem                   = false\r\n        else\r\n            //This should only happen for stuff like Spirit Link or Thorns Aura/Carapace\r\n            call afterDamage()\r\n            set Damage.index            = lastInstance\r\n            set lastInstance            = 0\r\n            set d                       = Damage.index\r\n            set canKick                 = true\r\n            call DamageTrigger.setGUIFromStruct(true)\r\n        endif\r\nstatic if USE_ARMOR_MOD then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        call d.setArmor(true)\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n       \r\nstatic if USE_SCALING then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        if udg_DamageEventAmount != 0.00 and r != 0.00 then\r\n            set udg_DamageScalingWC3    = r / udg_DamageEventAmount\r\n        elseif udg_DamageEventAmount > 0.00 then\r\n            set udg_DamageScalingWC3    = 0.00\r\n        else                      \r\n            set udg_DamageScalingWC3    = 1.00\r\n            if udg_DamageEventPrevAmt == 0.00 then\r\n                set udg_DamageScalingUser = 0.00\r\n            else\r\n                set udg_DamageScalingUser = udg_DamageEventAmount/udg_DamageEventPrevAmt\r\n            endif\r\n        endif                    \r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        set udg_DamageEventAmount       = r\r\n        set d.damage                    = r\r\n \r\n        //! runtextmacro optional DAMAGE_EVENT_VARS_PLUGIN_GDD()\r\n        //! runtextmacro optional DAMAGE_EVENT_VARS_PLUGIN_PDD()\r\n        //! runtextmacro optional DAMAGE_EVENT_VARS_PLUGIN_01()\r\n        //! runtextmacro optional DAMAGE_EVENT_VARS_PLUGIN_02()\r\n        //! runtextmacro optional DAMAGE_EVENT_VARS_PLUGIN_03()\r\n        //! runtextmacro optional DAMAGE_EVENT_VARS_PLUGIN_04()\r\n        //! runtextmacro optional DAMAGE_EVENT_VARS_PLUGIN_05()\r\n \r\n        if udg_DamageEventAmount > 0.00 then\r\n            call DamageTrigger.SHIELD.run()\r\nstatic if not USE_GUI then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            set udg_DamageEventAmount = d.damage\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\nstatic if USE_LETHAL then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            if hasLethal or udg_DamageEventType < 0 then\r\n                set udg_LethalDamageHP = GetWidgetLife(udg_DamageEventTarget) - udg_DamageEventAmount\r\n                if udg_LethalDamageHP <= DEATH_VAL then\r\n                    if hasLethal then\r\n                        call DamageTrigger.LETHAL.run()\r\n           \r\n                        set udg_DamageEventAmount = GetWidgetLife(udg_DamageEventTarget) - udg_LethalDamageHP\r\n                        set d.damage = udg_DamageEventAmount\r\n                    endif\r\n                    if udg_DamageEventType < 0 and udg_LethalDamageHP <= DEATH_VAL then\r\n                        call SetUnitExploded(udg_DamageEventTarget, true)\r\n                    endif\r\n                endif\r\n            endif\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\nstatic if USE_SCALING then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            if udg_DamageEventPrevAmt == 0.00 or udg_DamageScalingWC3 == 0.00 then\r\n                set udg_DamageScalingUser = 0.00\r\n            else\r\n                set udg_DamageScalingUser = udg_DamageEventAmount/udg_DamageEventPrevAmt/udg_DamageScalingWC3\r\n            endif\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n        endif\r\n        if udg_DamageEventDamageT != 0 then\r\n            call DamageTrigger.DAMAGE.run()\r\n        endif\r\n        call BlzSetEventDamage(udg_DamageEventAmount)\r\n        set eventsRun                   = true\r\n        if udg_DamageEventAmount == 0.00 then\r\n            call finish()\r\n        endif\r\n        return false\r\n    endmethod\r\n    static method apply takes unit src, unit tgt, real amt, boolean a, boolean r, attacktype at, damagetype dt, weapontype wt returns Damage\r\n        local Damage d\r\n        if udg_NextDamageType == 0 then\r\n           set udg_NextDamageType = TYPE_CODE\r\n        endif\r\n        if dreaming then\r\n            set d              = create(src, tgt, amt, a, at, dt, wt)\r\n            set d.isCode       = true\r\n            set d.eFilter      = FILTER_CODE\r\n                         \r\n            set d.userType     = udg_NextDamageType\r\nstatic if USE_MELEE_RANGE then// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            if not d.isSpell then\r\n                set d.isRanged = udg_NextDamageIsRanged or r\r\n                set d.isMelee  = not d.isRanged\r\n            endif\r\nendif// \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ / \\ /\r\n            call d.addRecursive()\r\n        else\r\n            call UnitDamageTarget(src, tgt, amt, a, r, at, dt, wt)\r\n            set d = Damage.index\r\n            call finish()\r\n        endif\r\n        call clearNexts()\r\n        return d\r\n    endmethod\r\n    static method applySpell takes unit src, unit tgt, real amt, damagetype dt returns Damage\r\n        return apply(src, tgt, amt, false, false, null, dt, null)\r\n    endmethod\r\n    static method applyAttack takes unit src, unit tgt, real amt, boolean ranged, attacktype at, weapontype wt returns Damage\r\n        return apply(src, tgt, amt, true, ranged, at, DAMAGE_TYPE_NORMAL, wt)\r\n    endmethod\r\n    //===========================================================================\r\n    private static method onInit takes nothing returns nothing\r\n        call TriggerRegisterAnyUnitEventBJ(t1, EVENT_PLAYER_UNIT_DAMAGING)\r\n        call TriggerAddCondition(t1, Filter(function Damage.onDamaging))\r\n \r\n        call TriggerRegisterAnyUnitEventBJ(t2, EVENT_PLAYER_UNIT_DAMAGED)\r\n        call TriggerAddCondition(t2, Filter(function Damage.onDamaged))\r\n \r\n        //For recursion\r\n        call TriggerRegisterAnyUnitEventBJ(t3, EVENT_PLAYER_UNIT_DAMAGING)\r\n        call TriggerAddCondition(t3, Filter(function Damage.onRecursion))\r\n        call DisableTrigger(t3)\r\n \r\n        //For preventing Thorns/Defensive glitch.\r\n        //Data gathered from https://www.hiveworkshop.com/threads/repo-in-progress-mapping-damage-types-to-their-abilities.316271/\r\n        set attacksImmune[0]  = false   //ATTACK_TYPE_NORMAL\r\n        set attacksImmune[1]  = true    //ATTACK_TYPE_MELEE  \r\n        set attacksImmune[2]  = true    //ATTACK_TYPE_PIERCE  \r\n        set attacksImmune[3]  = true    //ATTACK_TYPE_SIEGE  \r\n        set attacksImmune[4]  = false   //ATTACK_TYPE_MAGIC  \r\n        set attacksImmune[5]  = true    //ATTACK_TYPE_CHAOS  \r\n        set attacksImmune[6]  = true    //ATTACK_TYPE_HERO    \r\n \r\n        set damagesImmune[0]  = true    //DAMAGE_TYPE_UNKNOWN      \r\n        set damagesImmune[4]  = true    //DAMAGE_TYPE_NORMAL          \r\n        set damagesImmune[5]  = true    //DAMAGE_TYPE_ENHANCED        \r\n        set damagesImmune[8]  = false   //DAMAGE_TYPE_FIRE            \r\n        set damagesImmune[9]  = false   //DAMAGE_TYPE_COLD              \r\n        set damagesImmune[10] = false   //DAMAGE_TYPE_LIGHTNING        \r\n        set damagesImmune[11] = true    //DAMAGE_TYPE_POISON          \r\n        set damagesImmune[12] = true    //DAMAGE_TYPE_DISEASE          \r\n        set damagesImmune[13] = false   //DAMAGE_TYPE_DIVINE            \r\n        set damagesImmune[14] = false   //DAMAGE_TYPE_MAGIC            \r\n        set damagesImmune[15] = false   //DAMAGE_TYPE_SONIC            \r\n        set damagesImmune[16] = true    //DAMAGE_TYPE_ACID            \r\n        set damagesImmune[17] = false   //DAMAGE_TYPE_FORCE            \r\n        set damagesImmune[18] = false   //DAMAGE_TYPE_DEATH            \r\n        set damagesImmune[19] = false   //DAMAGE_TYPE_MIND              \r\n        set damagesImmune[20] = false   //DAMAGE_TYPE_PLANT            \r\n        set damagesImmune[21] = false   //DAMAGE_TYPE_DEFENSIVE        \r\n        set damagesImmune[22] = true    //DAMAGE_TYPE_DEMOLITION      \r\n        set damagesImmune[23] = true    //DAMAGE_TYPE_SLOW_POISON      \r\n        set damagesImmune[24] = false   //DAMAGE_TYPE_SPIRIT_LINK      \r\n        set damagesImmune[25] = false   //DAMAGE_TYPE_SHADOW_STRIKE    \r\n        set damagesImmune[26] = true    //DAMAGE_TYPE_UNIVERSAL\r\n    endmethod\r\n    //! runtextmacro optional DAMAGE_EVENT_STRUCT_PLUGIN_DMGPKG()\r\n    //! runtextmacro optional DAMAGE_EVENT_STRUCT_PLUGIN_01()\r\n    //! runtextmacro optional DAMAGE_EVENT_STRUCT_PLUGIN_02()\r\n    //! runtextmacro optional DAMAGE_EVENT_STRUCT_PLUGIN_03()\r\n    //! runtextmacro optional DAMAGE_EVENT_STRUCT_PLUGIN_04()\r\n    //! runtextmacro optional DAMAGE_EVENT_STRUCT_PLUGIN_05()\r\nendstruct\r\n    public function DebugStr takes nothing returns nothing\r\n        local integer i                      = 0\r\n        loop\r\n            set udg_CONVERTED_ATTACK_TYPE[i] = ConvertAttackType(i)\r\n            exitwhen i == 6\r\n            set i                            = i + 1\r\n        endloop\r\n        set i                                = 0\r\n        loop\r\n            set udg_CONVERTED_DAMAGE_TYPE[i] = ConvertDamageType(i)\r\n            exitwhen i == 26\r\n            set i                            = i + 1\r\n        endloop\r\n        set udg_AttackTypeDebugStr[0]        = \"SPELLS\"   //ATTACK_TYPE_NORMAL in JASS\r\n        set udg_AttackTypeDebugStr[1]        = \"NORMAL\"   //ATTACK_TYPE_MELEE in JASS\r\n        set udg_AttackTypeDebugStr[2]        = \"PIERCE\"\r\n        set udg_AttackTypeDebugStr[3]        = \"SIEGE\"\r\n        set udg_AttackTypeDebugStr[4]        = \"MAGIC\"\r\n        set udg_AttackTypeDebugStr[5]        = \"CHAOS\"\r\n        set udg_AttackTypeDebugStr[6]        = \"HERO\"\r\n        set udg_DamageTypeDebugStr[0]        = \"UNKNOWN\"\r\n        set udg_DamageTypeDebugStr[4]        = \"NORMAL\"\r\n        set udg_DamageTypeDebugStr[5]        = \"ENHANCED\"\r\n        set udg_DamageTypeDebugStr[8]        = \"FIRE\"\r\n        set udg_DamageTypeDebugStr[9]        = \"COLD\"\r\n        set udg_DamageTypeDebugStr[10]       = \"LIGHTNING\"\r\n        set udg_DamageTypeDebugStr[11]       = \"POISON\"\r\n        set udg_DamageTypeDebugStr[12]       = \"DISEASE\"\r\n        set udg_DamageTypeDebugStr[13]       = \"DIVINE\"\r\n        set udg_DamageTypeDebugStr[14]       = \"MAGIC\"\r\n        set udg_DamageTypeDebugStr[15]       = \"SONIC\"\r\n        set udg_DamageTypeDebugStr[16]       = \"ACID\"\r\n        set udg_DamageTypeDebugStr[17]       = \"FORCE\"\r\n        set udg_DamageTypeDebugStr[18]       = \"DEATH\"\r\n        set udg_DamageTypeDebugStr[19]       = \"MIND\"\r\n        set udg_DamageTypeDebugStr[20]       = \"PLANT\"\r\n        set udg_DamageTypeDebugStr[21]       = \"DEFENSIVE\"\r\n        set udg_DamageTypeDebugStr[22]       = \"DEMOLITION\"\r\n        set udg_DamageTypeDebugStr[23]       = \"SLOW_POISON\"\r\n        set udg_DamageTypeDebugStr[24]       = \"SPIRIT_LINK\"\r\n        set udg_DamageTypeDebugStr[25]       = \"SHADOW_STRIKE\"\r\n        set udg_DamageTypeDebugStr[26]       = \"UNIVERSAL\"\r\n        set udg_WeaponTypeDebugStr[0]        = \"NONE\"    //WEAPON_TYPE_WHOKNOWS in JASS\r\n        set udg_WeaponTypeDebugStr[1]        = \"METAL_LIGHT_CHOP\"\r\n        set udg_WeaponTypeDebugStr[2]        = \"METAL_MEDIUM_CHOP\"\r\n        set udg_WeaponTypeDebugStr[3]        = \"METAL_HEAVY_CHOP\"\r\n        set udg_WeaponTypeDebugStr[4]        = \"METAL_LIGHT_SLICE\"\r\n        set udg_WeaponTypeDebugStr[5]        = \"METAL_MEDIUM_SLICE\"\r\n        set udg_WeaponTypeDebugStr[6]        = \"METAL_HEAVY_SLICE\"\r\n        set udg_WeaponTypeDebugStr[7]        = \"METAL_MEDIUM_BASH\"\r\n        set udg_WeaponTypeDebugStr[8]        = \"METAL_HEAVY_BASH\"\r\n        set udg_WeaponTypeDebugStr[9]        = \"METAL_MEDIUM_STAB\"\r\n        set udg_WeaponTypeDebugStr[10]       = \"METAL_HEAVY_STAB\"\r\n        set udg_WeaponTypeDebugStr[11]       = \"WOOD_LIGHT_SLICE\"\r\n        set udg_WeaponTypeDebugStr[12]       = \"WOOD_MEDIUM_SLICE\"\r\n        set udg_WeaponTypeDebugStr[13]       = \"WOOD_HEAVY_SLICE\"\r\n        set udg_WeaponTypeDebugStr[14]       = \"WOOD_LIGHT_BASH\"\r\n        set udg_WeaponTypeDebugStr[15]       = \"WOOD_MEDIUM_BASH\"\r\n        set udg_WeaponTypeDebugStr[16]       = \"WOOD_HEAVY_BASH\"\r\n        set udg_WeaponTypeDebugStr[17]       = \"WOOD_LIGHT_STAB\"\r\n        set udg_WeaponTypeDebugStr[18]       = \"WOOD_MEDIUM_STAB\"\r\n        set udg_WeaponTypeDebugStr[19]       = \"CLAW_LIGHT_SLICE\"\r\n        set udg_WeaponTypeDebugStr[20]       = \"CLAW_MEDIUM_SLICE\"\r\n        set udg_WeaponTypeDebugStr[21]       = \"CLAW_HEAVY_SLICE\"\r\n        set udg_WeaponTypeDebugStr[22]       = \"AXE_MEDIUM_CHOP\"\r\n        set udg_WeaponTypeDebugStr[23]       = \"ROCK_HEAVY_BASH\"\r\n        set udg_DefenseTypeDebugStr[0]       = \"LIGHT\"\r\n        set udg_DefenseTypeDebugStr[1]       = \"MEDIUM\"\r\n        set udg_DefenseTypeDebugStr[2]       = \"HEAVY\"\r\n        set udg_DefenseTypeDebugStr[3]       = \"FORTIFIED\"\r\n        set udg_DefenseTypeDebugStr[4]       = \"NORMAL\"   //Typically deals flat damage to all armor types\r\n        set udg_DefenseTypeDebugStr[5]       = \"HERO\"\r\n        set udg_DefenseTypeDebugStr[6]       = \"DIVINE\"\r\n        set udg_DefenseTypeDebugStr[7]       = \"UNARMORED\"\r\n        set udg_ArmorTypeDebugStr[0]         = \"NONE\"      //ARMOR_TYPE_WHOKNOWS in JASS, added in 1.31\r\n        set udg_ArmorTypeDebugStr[1]         = \"FLESH\"\r\n        set udg_ArmorTypeDebugStr[2]         = \"METAL\"\r\n        set udg_ArmorTypeDebugStr[3]         = \"WOOD\"\r\n        set udg_ArmorTypeDebugStr[4]         = \"ETHEREAL\"\r\n        set udg_ArmorTypeDebugStr[5]         = \"STONE\"\r\n    endfunction\r\n    //===========================================================================\r\n    //\r\n    // Setup of automatic events from GUI and custom ones from JASS alike\r\n    //\r\n    //===========================================================================\r\n    public function RegisterFromHook takes trigger whichTrig, string var, limitop op, real value returns nothing\r\n        call DamageTrigger.registerVerbose(whichTrig, var, value, true, GetHandleId(op))\r\n    endfunction\r\n    hook TriggerRegisterVariableEvent RegisterFromHook\r\n    function TriggerRegisterDamageEngineEx takes trigger whichTrig, string eventName, real value, integer f returns DamageTrigger\r\n        return DamageTrigger.registerVerbose(whichTrig, DamageTrigger.getVerboseStr(eventName), value, false, f)\r\n    endfunction\r\n    function TriggerRegisterDamageEngine takes trigger whichTrig, string eventName, real value returns DamageTrigger\r\n        return DamageTrigger.registerTrigger(whichTrig, eventName, value)\r\n    endfunction\r\n    function RegisterDamageEngineEx takes code c, string eventName, real value, integer f returns DamageTrigger\r\n        return TriggerRegisterDamageEngineEx(DamageTrigger[c], eventName, value, f)\r\n    endfunction\r\n    //Similar to TriggerRegisterDamageEvent, although takes code instead of trigger as the first argument.\r\n    function RegisterDamageEngine takes code c, string eventName, real value returns DamageTrigger\r\n        return RegisterDamageEngineEx(c, eventName, value, FILTER_OTHER)\r\n    endfunction\r\n    //For GUI to tap into more powerful vJass event filtering:\r\n    //! textmacro DAMAGE_TRIGGER_CONFIG\r\n        if not DamageTrigger.eventIndex.configured then\r\n    //! endtextmacro\r\n    //! textmacro DAMAGE_TRIGGER_CONFIG_END\r\n            call DamageTrigger.eventIndex.configure()\r\n            if not DamageTrigger.eventIndex.checkConfiguration() then\r\n                return\r\n            endif\r\n        endif\r\n    //! endtextmacro\r\nendlibrary",
  "Events": [],
  "LocalVariables": [],
  "Conditions": [],
  "Actions": []
}