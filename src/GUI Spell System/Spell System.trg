{
  "Id": 50331757,
  "Comment": "",
  "IsScript": true,
  "RunOnMapInit": false,
  "Script": "function SpellIndexGetVars takes integer i returns nothing\r\n    set udg_Spell__Ability = udg_Spell_i_Abil[udg_Spell_i_Head[i]]\r\n    set udg_Spell__Index = i\r\n    set udg_Spell__Caster = udg_Spell_i_Caster[i]\r\n    set udg_Spell__CasterOwner = GetOwningPlayer(udg_Spell__Caster)\r\n    set udg_Spell__Level = udg_Spell_i_Level[i]\r\n    set udg_Spell__LevelMultiplier = udg_Spell__Level //Spell__LevelMultiplier is a real variable.\r\n    set udg_Spell__Target = udg_Spell_i_Target[i]\r\n    \r\n    //Magic to ensure the locations never leak.\r\n    call MoveLocation(udg_Spell__CastPoint, GetUnitX(udg_Spell__Caster), GetUnitY(udg_Spell__Caster))\r\n    if udg_Spell__Target == null then\r\n        call MoveLocation(udg_Spell__TargetPoint, udg_Spell_i_TargetX[i], udg_Spell_i_TargetY[i])\r\n    else\r\n        call MoveLocation(udg_Spell__TargetPoint, GetUnitX(udg_Spell__Target), GetUnitY(udg_Spell__Target))\r\n    endif\r\n    set udg_Spell__TargetGroup = udg_Spell_i_TargetGroup[i]\r\n    set udg_Spell__Completed = udg_Spell_i_Completed[i]\r\n    set udg_Spell__Channeling = udg_Spell_i_Channeling[i]\r\nendfunction\r\n\r\nfunction SpellSetFilters takes integer i returns nothing\r\n    set udg_Spell_i_AllowEnemy[i]       = udg_Spell__Filter_AllowEnemy\r\n    set udg_Spell_i_AllowAlly[i]        = udg_Spell__Filter_AllowAlly\r\n    set udg_Spell_i_AllowDead[i]        = udg_Spell__Filter_AllowDead\r\n    set udg_Spell_i_AllowLiving[i]      = udg_Spell__Filter_AllowLiving\r\n    set udg_Spell_i_AllowMagicImmune[i] = udg_Spell__Filter_AllowMagicImmune\r\n    set udg_Spell_i_AllowMechanical[i]  = udg_Spell__Filter_AllowMechanical\r\n    set udg_Spell_i_AllowStructure[i]   = udg_Spell__Filter_AllowStructure\r\n    set udg_Spell_i_AllowFlying[i]      = udg_Spell__Filter_AllowFlying\r\n    set udg_Spell_i_AllowHero[i]        = udg_Spell__Filter_AllowHero\r\n    set udg_Spell_i_AllowNonHero[i]     = udg_Spell__Filter_AllowNonHero\r\nendfunction\r\n\r\nfunction SpellIndexDestroy takes integer i returns nothing\r\n    local integer indexOf\r\n    local integer index\r\n    if udg_Spell_i_RecycleList[i] >= 0 then\r\n        return\r\n    endif\r\n    //If the caster is still channeling on the spell, don't destroy until it's finished:\r\n    if not udg_Spell_i_Channeling[i] then\r\n        set index = udg_Spell_i_Head[i]\r\n        set udg_Spell_i_RecycleList[i] = udg_Spell_i_Recycle\r\n        set udg_Spell_i_Recycle = i\r\n        \r\n        //Reset things to defaults:\r\n        set udg_Spell_i_Time[i] = 0.00\r\n        set udg_Spell_i_LastTime[i] = 0.00\r\n        set udg_Spell_i_Duration[i] = 0.00\r\n        set udg_Spell_i_Completed[i] = false\r\n        set udg_Spell_i_Caster[i] = null\r\n        set udg_Spell_i_Target[i] = null\r\n        set udg_Spell_i_OnLoopStack[i] = null\r\n        \r\n        //Recycle any applicable target unit group.\r\n        if udg_Spell_i_TargetGroup[i] != null then\r\n            call GroupClear(udg_Spell_i_TargetGroup[i])\r\n            set udg_Spell_i_GroupStack[udg_Spell_i_GroupN] = udg_Spell_i_TargetGroup[i]\r\n            set udg_Spell_i_GroupN = udg_Spell_i_GroupN + 1\r\n            set udg_Spell_i_TargetGroup[i] = null\r\n        endif\r\n        \r\n        //Clear any user-specified data in the hashtable:\r\n        call FlushChildHashtable(udg_Spell__Hash, i)\r\n        //call BJDebugMsg(\"Destroying index: \" + I2S(i))\r\n    endif\r\n    \r\n    set indexOf = udg_Spell_i_StackRef[i]\r\n    if indexOf >= 0 then\r\n        set index = udg_Spell_i_StackN - 1\r\n        set udg_Spell_i_StackN = index\r\n        \r\n        set udg_Spell_i_StackRef[udg_Spell_i_Stack[index]] = indexOf\r\n        set udg_Spell_i_Stack[indexOf] = udg_Spell_i_Stack[index]\r\n        if index == 0 then\r\n            //If no more spells require the timer, pause it.\r\n            call PauseTimer(udg_Spell_i_Timer)\r\n        endif\r\n        set udg_Spell_i_StackRef[i] = -1\r\n    endif\r\nendfunction\r\n\r\nfunction SpellTriggerExecute takes integer i, trigger t returns real\r\n    local real d = udg_Spell_i_Duration[i]\r\n    local boolean b = false\r\n    set udg_Spell__Duration = d\r\n    set udg_Spell__Time = 0.00\r\n    if t != null then\r\n        set udg_Spell__Trigger_OnLoop = null\r\n        set udg_Spell__Expired = d <= 0.00 //If the duration is <= 0, the spell has expired.\r\n        call SpellIndexGetVars(i)\r\n        if TriggerEvaluate(t) then\r\n            call TriggerExecute(t)\r\n        endif\r\n        if udg_Spell__Trigger_OnLoop != null then\r\n            set udg_Spell_i_OnLoopStack[i] = udg_Spell__Trigger_OnLoop\r\n        endif\r\n        //The remaining lines in this function process the duration specified by the user.\r\n        if udg_Spell__StartDuration then\r\n            set udg_Spell__StartDuration = false\r\n            set udg_Spell__Duration = udg_Spell_i_Duration[udg_Spell_i_Head[i]] + udg_Spell_i_LastTime[udg_Spell_i_Head[i]]*udg_Spell__LevelMultiplier\r\n        elseif (udg_Spell__Expired and d > 0.00) or (udg_Spell__Duration <= 0.00) then\r\n            set udg_Spell__Duration = 0.00\r\n            return udg_Spell__Time\r\n            //The user manually expired the spell or the spell duration ended on its own.\r\n        endif\r\n        if d != udg_Spell__Duration then\r\n            //A new duration has been assigned\r\n            set d = udg_Spell__Duration\r\n            set b = true\r\n        endif\r\n        set udg_Spell__Duration = 0.00\r\n        if udg_Spell__Time == 0.00 then\r\n            if udg_Spell_i_LastTime[i] == 0.00 then\r\n                if udg_Spell_i_Time[udg_Spell_i_Head[i]] > 0.00 then\r\n                    //The user specified a default interval to follow:\r\n                    set udg_Spell__Time = udg_Spell_i_Time[udg_Spell_i_Head[i]]\r\n                else\r\n                    //Set the spell time to the minimum.\r\n                    set udg_Spell__Time = udg_Spell__Interval\r\n                endif\r\n            else\r\n                //Otherwise, set it to what it was before.\r\n                set udg_Spell__Time = udg_Spell_i_LastTime[i]\r\n            endif\r\n        //else, the user is specifying a new time for the spell.\r\n        endif\r\n        set udg_Spell_i_LastTime[i] = udg_Spell__Time //Whatever the case, remember this time for next time.\r\n        if b then\r\n            //The duration was just assigned\r\n            set udg_Spell_i_Duration[i] = d\r\n        else\r\n            //The duration has been ongoing\r\n            set udg_Spell_i_Duration[i] = d - udg_Spell__Time\r\n        endif\r\n    endif\r\n    return udg_Spell__Time\r\nendfunction\r\n\r\n//===========================================================================\r\n// Runs every Spell__Interval seconds and handles all of the timed events.\r\n// \r\nfunction SpellTimerLoop takes nothing returns nothing\r\n    local integer i = udg_Spell_i_StackN\r\n    local integer node\r\n    local real time\r\n    set udg_Spell__Running = true\r\n    \r\n    //Run stack top to bottom to avoid skipping slots when destroying.\r\n    loop\r\n        set i = i - 1\r\n        exitwhen i < 0\r\n        set node = udg_Spell_i_Stack[i]\r\n        set time = udg_Spell_i_Time[node] - udg_Spell__Interval\r\n        if time <= 0.00 then\r\n            set time = SpellTriggerExecute(node, udg_Spell_i_OnLoopStack[node])\r\n        endif\r\n        if time <= 0.00 then\r\n            call SpellIndexDestroy(node)\r\n        else\r\n            set udg_Spell_i_Time[node] = time\r\n        endif\r\n    endloop\r\n    set udg_Spell__Running = false\r\nendfunction\r\n\r\n//===========================================================================\r\n// This is the meat of the system as it handles the event responses.\r\n// \r\nfunction RunSpellEvent takes nothing returns boolean\r\n    local boolean b\r\n    local integer aid = GetSpellAbilityId()\r\n    local integer head = LoadInteger(udg_Spell__Hash, 0, aid)\r\n    local integer i\r\n    local integer id\r\n    local trigger t\r\n    local playerunitevent eid\r\n    if head == 0 then\r\n        //Nothing for this ability has been registered. Skip the sequence.\r\n        return false\r\n    endif\r\n    set eid = ConvertPlayerUnitEvent(GetHandleId(GetTriggerEventId()))\r\n    set udg_Spell__Caster = GetTriggerUnit()\r\n    set id = GetHandleId(udg_Spell__Caster)\r\n    set i = LoadInteger(udg_Spell__Hash, aid, id)\r\n    if i == 0 then\r\n        //This block will almost always happen with the OnChannel event. In the\r\n        //case of Charge Gold and Lumber, only an OnEffect event will run.\r\n        set i = udg_Spell_i_Recycle\r\n        if i == 0 then\r\n            //Create a new, unique index\r\n            set i = udg_Spell_i_Instances + 1\r\n            set udg_Spell_i_Instances = i\r\n        else\r\n            //Repurpose an existing one\r\n            set udg_Spell_i_Recycle = udg_Spell_i_RecycleList[i]\r\n        endif\r\n        //call BJDebugMsg(\"Creating index: \" + I2S(i))\r\n        set udg_Spell_i_RecycleList[i] = -1\r\n        set udg_Spell_i_StackRef[i] = -1\r\n        set udg_Spell_i_Head[i] = head\r\n        \r\n        if eid == EVENT_PLAYER_UNIT_SPELL_CHANNEL then\r\n            set udg_Spell_i_Channeling[i] = true\r\n            call SaveInteger(udg_Spell__Hash, aid, id, i)\r\n            set t = udg_Spell_i_OnChannelStack[head]\r\n        else //eid == EVENT_PLAYER_UNIT_SPELL_EFFECT\r\n            set t = udg_Spell_i_OnEffectStack[head]\r\n        endif\r\n        set udg_Spell_i_Caster[i] = udg_Spell__Caster\r\n        set udg_Spell_i_Level[i] = GetUnitAbilityLevel(udg_Spell__Caster, aid)\r\n        set udg_Spell_i_Target[i] = GetSpellTargetUnit()\r\n        set udg_Spell_i_TargetX[i] = GetSpellTargetX()\r\n        set udg_Spell_i_TargetY[i] = GetSpellTargetY()\r\n        \r\n        set udg_Spell_i_OnLoopStack[i] = udg_Spell_i_OnLoopStack[head]\r\n        if udg_Spell_i_UseTG[head] then\r\n            //Get a recycled unit group or create a new one.\r\n            set id = udg_Spell_i_GroupN - 1\r\n            if id >= 0 then\r\n                set udg_Spell_i_GroupN = id\r\n                set udg_Spell_i_TargetGroup[i] = udg_Spell_i_GroupStack[id]\r\n            else\r\n                set udg_Spell_i_TargetGroup[i] = CreateGroup()\r\n            endif\r\n        endif\r\n    elseif eid == EVENT_PLAYER_UNIT_SPELL_CAST then\r\n        set t = udg_Spell_i_OnCastStack[head]\r\n    elseif eid == EVENT_PLAYER_UNIT_SPELL_EFFECT then\r\n        set t = udg_Spell_i_OnEffectStack[head]\r\n    elseif eid == EVENT_PLAYER_UNIT_SPELL_FINISH then\r\n        set udg_Spell_i_Completed[i] = true\r\n        return true\r\n    else //eid == EVENT_PLAYER_UNIT_SPELL_ENDCAST\r\n        set udg_Spell_i_Channeling[i] = false\r\n        call RemoveSavedInteger(udg_Spell__Hash, aid, id)\r\n        set t = udg_Spell_i_OnFinishStack[head]\r\n    endif\r\n    if SpellTriggerExecute(i, t) > 0.00 then\r\n        //Set the spell time to the user-specified one.\r\n        set udg_Spell_i_Time[i] = udg_Spell__Time\r\n        if udg_Spell_i_StackRef[i] < 0 then\r\n            //Allocate the spell index onto the loop stack.\r\n            set aid = udg_Spell_i_StackN\r\n            set udg_Spell_i_Stack[aid] = i\r\n            set udg_Spell_i_StackRef[i] = aid\r\n            set udg_Spell_i_StackN = aid + 1\r\n            if aid == 0 then\r\n                //If this is the first spell index using the timer, start it up:\r\n                call TimerStart(udg_Spell_i_Timer, udg_Spell__Interval, true, function SpellTimerLoop)\r\n            endif\r\n        endif\r\n    elseif (not udg_Spell_i_Channeling[i]) and (t != null or udg_Spell_i_Time[i] <= 0.00) then\r\n        call SpellIndexDestroy(i)\r\n    endif\r\n    set t = null\r\n    return true\r\nendfunction\r\n\r\n//This function is invoked if an event was launched recursively by another event's callback.\r\nfunction RunPreSpellEvent takes nothing returns nothing\r\n    local integer i = udg_Spell__Index\r\n    local real time = udg_Spell__Time\r\n    local real d = udg_Spell__Duration\r\n    local boolean expired = udg_Spell__Expired\r\n    if udg_Spell__Trigger_OnLoop != null then\r\n        set udg_Spell_i_OnLoopStack[i] = udg_Spell__Trigger_OnLoop\r\n    endif\r\n    if RunSpellEvent() then\r\n        set udg_Spell__Time = time\r\n        set udg_Spell__Duration = d\r\n        set udg_Spell__Expired = expired\r\n        call SpellIndexGetVars(i)\r\n    endif\r\nendfunction\r\n\r\n//===========================================================================\r\n// Base function of the system: runs when an ability event does something.\r\n// \r\nfunction SpellSystemEvent takes nothing returns boolean\r\n    if udg_Spell__Running then\r\n        call RunPreSpellEvent()\r\n    else\r\n        set udg_Spell__Running = true\r\n        call RunSpellEvent()\r\n        set udg_Spell__Running = false\r\n    endif\r\n    return false\r\nendfunction\r\n\r\n//===========================================================================\r\n// Set Spell__Ability to your spell's ability\r\n// Set Spell__Trigger_OnChannel/Cast/Effect/Finish/Loop to any trigger(s) you\r\n// want to automatically run.\r\n// \r\n// GUI-friendly: Run Spell System <gen> (ignoring conditions)\r\n// \r\nfunction SpellSystemRegister takes nothing returns nothing\r\n    local integer aid = udg_Spell__Ability\r\n    local integer head = udg_Spell_i_Instances + 1\r\n    \r\n    if HaveSavedInteger(udg_Spell__Hash, 0, aid) or aid == 0 then\r\n        //The system rejects duplicate or unassigned abilities.\r\n        return\r\n    endif\r\n    set udg_Spell_i_Instances = head\r\n    set udg_Spell_i_Abil[head] = aid\r\n    \r\n    //Preload the ability on dummy unit to help prevent first-instance lag\r\n    call UnitAddAbility(udg_Spell_i_PreloadDummy, aid)\r\n    \r\n    //Save head index to the spell ability so it be referenced later.\r\n    call SaveInteger(udg_Spell__Hash, 0, aid, head)\r\n    \r\n    //Set any applicable event triggers.\r\n    set udg_Spell_i_OnChannelStack[head]= udg_Spell__Trigger_OnChannel\r\n    set udg_Spell_i_OnCastStack[head]   = udg_Spell__Trigger_OnCast\r\n    set udg_Spell_i_OnEffectStack[head] = udg_Spell__Trigger_OnEffect\r\n    set udg_Spell_i_OnFinishStack[head] = udg_Spell__Trigger_OnFinish\r\n    set udg_Spell_i_OnLoopStack[head]   = udg_Spell__Trigger_OnLoop\r\n    set udg_Spell_i_InRangeFilter[head] = udg_Spell__Trigger_InRangeFilter\r\n    \r\n    //Set any customized filter variables:\r\n    call SpellSetFilters(head)\r\n    \r\n    //Tell the system to automatically create target groups, if needed\r\n    set udg_Spell_i_AutoAddTargets[head] = udg_Spell__AutoAddTargets\r\n    set udg_Spell_i_UseTG[head] = udg_Spell__UseTargetGroup or udg_Spell__AutoAddTargets\r\n    \r\n    //Handle automatic buff assignment\r\n    set udg_Spell_i_BuffAbil[head] = udg_Spell__BuffAbility\r\n    set udg_Spell_i_BuffOrder[head] = udg_Spell__BuffOrder\r\n    \r\n    //Set the default time sequences if a duration is used:\r\n    set udg_Spell_i_Time[head]     = udg_Spell__Time\r\n    set udg_Spell_i_Duration[head] = udg_Spell__Duration\r\n    set udg_Spell_i_LastTime[head] = udg_Spell__DurationPerLevel\r\n    \r\n    //Set variables back to their defaults:\r\n    set udg_Spell__Trigger_OnChannel    = null\r\n    set udg_Spell__Trigger_OnCast       = null\r\n    set udg_Spell__Trigger_OnEffect     = null\r\n    set udg_Spell__Trigger_OnFinish     = null\r\n    set udg_Spell__Trigger_OnLoop       = null\r\n    set udg_Spell__Trigger_InRangeFilter= null\r\n    set udg_Spell__AutoAddTargets       = false\r\n    set udg_Spell__UseTargetGroup       = false\r\n    set udg_Spell__Time                 = 0.00\r\n    set udg_Spell__Duration             = 0.00\r\n    set udg_Spell__DurationPerLevel     = 0.00\r\n    set udg_Spell__BuffAbility          = 0\r\n    set udg_Spell__BuffOrder            = 0\r\n    \r\n    set udg_Spell__Filter_AllowEnemy        = udg_Spell_i_AllowEnemy[0]\r\n    set udg_Spell__Filter_AllowAlly         = udg_Spell_i_AllowAlly[0]\r\n    set udg_Spell__Filter_AllowDead         = udg_Spell_i_AllowDead[0]\r\n    set udg_Spell__Filter_AllowMagicImmune  = udg_Spell_i_AllowMagicImmune[0]\r\n    set udg_Spell__Filter_AllowMechanical   = udg_Spell_i_AllowMechanical[0]\r\n    set udg_Spell__Filter_AllowStructure    = udg_Spell_i_AllowStructure[0]\r\n    set udg_Spell__Filter_AllowFlying       = udg_Spell_i_AllowFlying[0]\r\n    set udg_Spell__Filter_AllowHero         = udg_Spell_i_AllowHero[0]\r\n    set udg_Spell__Filter_AllowNonHero      = udg_Spell_i_AllowNonHero[0]\r\n    set udg_Spell__Filter_AllowLiving       = udg_Spell_i_AllowLiving[0]\r\nendfunction\r\n\r\nfunction SpellFilterCompare takes boolean is, boolean yes, boolean no returns boolean\r\n    return (is and yes) or ((not is) and no)\r\nendfunction\r\n\r\n//===========================================================================\r\n// Before calling this function, set Spell__InRangePoint to whatever point\r\n// you need, THEN set Spell__InRange to the radius you need. The system will\r\n// enumerate the units matching the configured filter and fill them into\r\n// Spell_InRangeGroup.\r\n// \r\nfunction SpellGroupUnitsInRange takes nothing returns boolean\r\n    local integer i = udg_Spell_i_Head[udg_Spell__Index]\r\n    local integer j = 0\r\n    local unit u\r\n    local real padding = 64.00\r\n    if udg_Spell_i_AllowStructure[i] then\r\n        //A normal unit can only have up to size 64.00 collision, but if the\r\n        //user needs to check for structures we need a padding big enough for\r\n        //the \"fattest\" ones: Tier 3 town halls.\r\n        set padding = 197.00\r\n    endif\r\n    call GroupEnumUnitsInRangeOfLoc(udg_Spell__InRangeGroup, udg_Spell__InRangePoint, udg_Spell__InRange + padding, null)\r\n    loop\r\n        set u = FirstOfGroup(udg_Spell__InRangeGroup)\r\n        exitwhen u == null\r\n        call GroupRemoveUnit(udg_Spell__InRangeGroup, u)\r\n        loop\r\n            exitwhen udg_Spell_i_AutoAddTargets[i] and IsUnitInGroup(u, udg_Spell__TargetGroup)\r\n            exitwhen not IsUnitInRangeLoc(u, udg_Spell__InRangePoint, udg_Spell__InRange)\r\n            exitwhen not SpellFilterCompare(IsUnitType(u, UNIT_TYPE_DEAD), udg_Spell_i_AllowDead[i], udg_Spell_i_AllowLiving[i])\r\n            exitwhen not SpellFilterCompare(IsUnitAlly(u, udg_Spell__CasterOwner), udg_Spell_i_AllowAlly[i], udg_Spell_i_AllowEnemy[i])\r\n            exitwhen not SpellFilterCompare(IsUnitType(u, UNIT_TYPE_HERO) or IsUnitType(u, UNIT_TYPE_RESISTANT), udg_Spell_i_AllowHero[i], udg_Spell_i_AllowNonHero[i])\r\n            exitwhen IsUnitType(u, UNIT_TYPE_STRUCTURE) and not udg_Spell_i_AllowStructure[i]\r\n            exitwhen IsUnitType(u, UNIT_TYPE_FLYING) and not udg_Spell_i_AllowFlying[i]\r\n            exitwhen IsUnitType(u, UNIT_TYPE_MECHANICAL) and not udg_Spell_i_AllowMechanical[i]\r\n            exitwhen IsUnitType(u, UNIT_TYPE_MAGIC_IMMUNE) and not udg_Spell_i_AllowMagicImmune[i]\r\n            set udg_Spell__InRangeUnit = u\r\n            //Run the user's designated filter, if one exists.\r\n            exitwhen udg_Spell_i_InRangeFilter[i] != null and not TriggerEvaluate(udg_Spell_i_InRangeFilter[i])\r\n            set j = j + 1\r\n            set udg_Spell__InRangeUnits[j] = u\r\n            exitwhen true\r\n        endloop\r\n    endloop\r\n    if j > udg_Spell__InRangeMax and udg_Spell__InRangeMax > 0 then\r\n        //The user has defined a maximum number of units allowed in the group.\r\n        //Remove a random unit until the total does not exceed capacity.\r\n        loop\r\n            set i = GetRandomInt(1, j)\r\n            set udg_Spell__InRangeUnits[i] = udg_Spell__InRangeUnits[j]\r\n            set j = j - 1\r\n            exitwhen j == udg_Spell__InRangeMax\r\n        endloop\r\n    endif\r\n    set udg_Spell__InRangeCount = j\r\n    set udg_Spell__InRangeMax = 0\r\n    set udg_Spell__InRange = 0.00\r\n    set i = udg_Spell_i_Head[udg_Spell__Index]\r\n    loop\r\n        exitwhen j == 0\r\n        set u = udg_Spell__InRangeUnits[j]\r\n        call GroupAddUnit(udg_Spell__InRangeGroup, u)\r\n        if udg_Spell_i_AutoAddTargets[i] then\r\n            call GroupAddUnit(udg_Spell__TargetGroup, u)\r\n        endif\r\n        if udg_Spell__WakeTargets and UnitIsSleeping(u) then\r\n            call UnitWakeUp(u)\r\n        endif\r\n        if udg_Spell_i_BuffAbil[i] != 0 and udg_Spell_i_BuffOrder[i] != 0 then\r\n            //Auto-buff units added to group:\r\n            call UnitAddAbility(udg_Spell_i_PreloadDummy, udg_Spell_i_BuffAbil[i])\r\n            call IssueTargetOrderById(udg_Spell_i_PreloadDummy, udg_Spell_i_BuffOrder[i], u)\r\n            call UnitRemoveAbility(udg_Spell_i_PreloadDummy, udg_Spell_i_BuffAbil[i])\r\n        endif\r\n        set j = j - 1\r\n    endloop\r\n    set u = null\r\n    return false\r\nendfunction\r\n\r\nfunction SpellPreloadEnd takes nothing returns nothing\r\n    local integer i = udg_Spell_i_Instances\r\n    loop\r\n        exitwhen i == 0\r\n        //Remove preloaded abilities so they don't interfere with orders\r\n        call UnitRemoveAbility(udg_Spell_i_PreloadDummy, udg_Spell_i_Abil[udg_Spell_i_Head[i]])\r\n        set i = i - 1\r\n    endloop\r\nendfunction\r\n\r\n//===========================================================================\r\nfunction InitTrig_Spell_System takes nothing returns nothing\r\n    local integer i = bj_MAX_PLAYER_SLOTS\r\n    local player p\r\n    local trigger t\r\n    \r\n    if gg_trg_Spell_System != null then\r\n        //A JASS function call already initialized the system.\r\n        return\r\n    endif\r\n    \r\n    //This runs before map init events so the hashtable is ready before then.\r\n    set udg_Spell__Hash = InitHashtable()\r\n    \r\n    //Initialize these two locations which will never get removed\r\n    set udg_Spell__CastPoint = Location(0, 0)\r\n    set udg_Spell__TargetPoint = Location(0, 0)\r\n    \r\n    //Recycle existing unit groups into the recycle stack to avoid needing to destroy any extras.\r\n    set udg_Spell_i_GroupStack[2] = udg_Spell__TargetGroup\r\n    set udg_Spell_i_GroupStack[3] = udg_Spell_i_TargetGroup[0]\r\n    set udg_Spell_i_GroupStack[4] = udg_Spell_i_TargetGroup[1]\r\n    set udg_Spell_i_GroupN = 5 //There are already five valid unit groups thanks to Variable Editor.\r\n    \r\n    set t = CreateTrigger()\r\n    call TriggerRegisterVariableEvent(t, \"udg_Spell__InRange\", GREATER_THAN, 0.00)\r\n    call TriggerAddCondition(t, Filter(function SpellGroupUnitsInRange))\r\n    \r\n    set t = CreateTrigger()\r\n    call TriggerAddCondition(t, Filter(function SpellSystemEvent))\r\n    loop\r\n        set i = i - 1\r\n        set p = Player(i)\r\n        call TriggerRegisterPlayerUnitEvent(t, p, EVENT_PLAYER_UNIT_SPELL_CHANNEL, null)\r\n        call TriggerRegisterPlayerUnitEvent(t, p, EVENT_PLAYER_UNIT_SPELL_CAST, null)\r\n        call TriggerRegisterPlayerUnitEvent(t, p, EVENT_PLAYER_UNIT_SPELL_EFFECT, null)\r\n        call TriggerRegisterPlayerUnitEvent(t, p, EVENT_PLAYER_UNIT_SPELL_FINISH, null)\r\n        call TriggerRegisterPlayerUnitEvent(t, p, EVENT_PLAYER_UNIT_SPELL_ENDCAST, null)\r\n        exitwhen i == 0\r\n    endloop\r\n    set p = null\r\n    set t = null\r\n    \r\n    //Run the configuration trigger so its variables are ready before the\r\n    //map initialization events run.\r\n    call TriggerExecute(gg_trg_Spell_System_Config)\r\n    call SpellSetFilters(0)\r\n    \r\n    //Create this trigger so it's GUI-friendly.\r\n    set gg_trg_Spell_System = CreateTrigger()\r\n    call TriggerAddAction(gg_trg_Spell_System, function SpellSystemRegister)\r\n    set gg_trg_Spell_System_Config = gg_trg_Spell_System //In case the user accidentally picks this one\r\n    \r\n    //Create a dummy unit for preloading abilities and casting buffs.\r\n    set udg_Spell_i_PreloadDummy = CreateUnit(udg_Spell__DummyOwner, udg_Spell__DummyType, 0, 0, 0)\r\n    \r\n    //Start the timer to remove its abilities:\r\n    call TimerStart(udg_Spell_i_Timer, 0.00, false, function SpellPreloadEnd)\r\n    call UnitRemoveAbility(udg_Spell_i_PreloadDummy, 'Amov') //Force it to never move to cast spells\r\nendfunction\r\n",
  "Events": [],
  "LocalVariables": [],
  "Conditions": [],
  "Actions": []
}